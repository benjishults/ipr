(forall ((a) (b))
  (for-some ((x))
    (implies (and (p a) (q b))
      (and (p x) (q x))))) ; not a theorem

(forall ((a) (b))
  (implies (and (q2 a b)
                (r b)
                (forall ((y))
                  (implies (r y) (p2 (f y) y))))
    (for-some ((x))
      (for-some ((y))
        (and (p2 x y)
             (q2 x y))))))

; q=3 slow
(implies (and (forall ((x) (y) (z))        ; not a theorem
                (implies (and (r2 x y) (r2 y z)) (r2 x z)))
              (forall ((x)) (for-some ((y)) (r2 x y))))
  (for-some ((x)) (r2 x x)))
;; 0.06 no
;; with interaction: yes
;; 0.07 no
;; with interaction: yes
;; 0.08 yes (It would finish sooner if we unified.)
;; 0.11 no
;; set0.04 yes

; q=3 slow and fails to prove
(forall ((a) (b))                        ; not a theorem
  (implies (q a)
    (for-some ((x)) (and (implies (p x) (p a))
          (implies (p x) (p b))
          (q x)))))
;; 0.11 no (runs forever)
;; set0.03 yes
;; relset0.05 no

(implies (and (for-some ((x)) (p x)) (for-some ((x)) (q x)))
  (for-some ((y)) (and (p y) (q y))))
                                        ;not a theorem
;; 0.07 no

(implies (and (for-some ((x)) (p x)) (for-some ((x)) (q x)))
                 (for-some ((x)) (and (p x) (q x))))        ; not a theorem
;; 0.06 no
;; 0.08 yes (I think I need to keep track of dependencies.)
;; (shows need to check if a unifier satisfies old goals,
;; or, as Bledsoe does, apply the old unifier first then
;; try to get a new one with which the old one will compose.)
;; 0.11 no (halts)

(forall ((a) (b) (c))
  (implies (and (p a) (p b) (p c))
    (for-some ((x))
      (and (p x) (q x))))) ; not a theorem

(forall ((a) (b))
  (implies
    (forall ((y))
      (implies (implies (r b) (r y))
                 (p2 (f y) y)))
        (for-some ((x))
          (for-some ((y))
            (and (p2 x y)
                 (implies (q2 a b)
                   (q2 x y))))) ))

(forall ((x)) (implies (t x) (t (b2 x))))
(forall ((x) (y)) (t (i (b2 (i x y)) (i (b2 x) (b2 y)))))
(forall ((x) (y)) (t (i x (i y x))))
(forall ((x) (y) (z)) (t (i (i x (i y z)) (i (i x y) (i x z)))))
(forall ((x) (y)) (t (i (i (n x) (n y)) (i y x))))
(forall ((x) (y)) (implies (and (t (i x y)) (t x)) (t y)))

(forall ((x)) (implies (p x) (q x))) ;not a theorem
;; 0.07 no

(implies (for-some ((x)) (p x)) (forall ((x)) (p x))) ;not a theorem
;; 0.07 no

(implies (and (r (a0)) (not (q (b0))))            ;not a theorem
         (for-some ((x)) (and (implies (p x) (q x)) (r x))))
;;0.07 no

;;for checking detail.  not a theorem.
(implies
 (and (implies (and (a0) (b0)) (c))
      (implies (and (a1) (a20)) (a0))
      (implies (and (a11) (a12)) (a1))
      (implies (truth) (a11))
      (implies (truth) (a12))
      (implies (truth) (a20))
      (implies (and (b1) (b20)) (b0))
      (implies (truth) (b1))
      (implies (and (e) (f)) (c)))
 (c))
;; 0.07 no

(implies (and (implies (and (a0) (b0)) (c))
              (implies (truth) (a0))) (c)) ;not a theorem
;; 0.07 no

(forall ((a) (b)) (for-some ((x)) (and (< a x) (< x b))))    ;not a theorem
;;0.07

(implies (or (r0) (p0)) (or (and (p0) (q0)) (r0))) ; not a theorem
;;; this tests to make sure condense is sound.

(implies
    (forall ((x)) (for-some ((y)) (a2         x y)))
  (for-some ((z)) (a2         z z)))                ; not a theorem
;; 0.07 no
;; 0.08 yes
;; (shows need to check if a unifier satisfies old goals,
;; or, as Bledsoe does, apply the old unifier first then
;; try to get a new one with which the old one will compose.)
;; 0.11 no

(forall ((a) (b) (c) (d) (e) (f) (z) (y) (x))
  (implies (and (p3 a b z) (q4 a b d y) (r3 a b f) (r3 e c d))
    (and (p3 x y z) (q4 a y z c) (r3 x y z)))) ; not a theorem
;; 0.08 no
;; 0.11 no (halts)

(implies (forall ((x)) (or (p x) (q x))) ; not a theorem
  (or (forall ((x)) (p x)) (forall ((x)) (q x))))
;; 0.06 no
;; 0.08 yes
;; (the problem is that the unifier doesn't keep track
;; of what has been unified with what.)
;; (shows need to check if a unifier satisfies old goals,
;; or, as Bledsoe does, apply the old unifier first then
;; try to get a new one with which the old one will compose.)
;; 0.11 no (halts)

(implies (forall ((x)) (for-some ((y)) (p2 x y))) ; not a theorem
                 (for-some ((y)) (forall ((x)) (p2 x y))))
;; 0.06 no
;; 0.08 yes
;; (this one shows the need for some sort of dependency tracking.)
;; 0.11 no (halts)

(for-some ((x)) (p x))                        ; not a theorem
;; 0.06 no
;; 0.08 no
;; 0.11 no (halts)

(not (for-some ((x)) (p x)))                ; not a theorem
;; 0.06 no
;; 0.08 no
;; 0.11 no (halts)

(forall ((x)) (p x))                        ; not a theorem
;; 0.06 no
;; 0.08 no
;; 0.11 no (halts)

(not (forall ((x)) (p x)))                ; not a theorem
;; 0.06 no
;; 0.08 no
;; 0.11 no (halts)

(forall ((x)) (implies (implies (p x) (q x)) ; not a theorem
                (implies (forall ((x)) (p x))
                  (forall ((x)) (q x)))))
;; 0.06 no
;; 0.08 no
;; 0.11 no (halts)

(and (forall ((x)) (for-some ((y)) (r2 x y)))
     (not (for-some ((x)) (r2 x x)))        ; not a theorem
     (forall ((x) (y) (z)) (implies (and (r2 x y) (r2 y z))
                             (r2 x z))))
;; 0.06 no
;; 0.08 no
;; 0.11 no (halts)

(implies (for-some ((x) (y)) (p2 x y))
  (for-some ((x)) (p2 x x))) ; not a theorem
;; 0.06 no
;; 0.08 no
;; 0.11 no (halts)

(implies (for-some ((x)) (p x)) (forall ((z)) (p z)))
                         ; not a theorem
;; 0.07 no
;; 0.08 no
;; 0.11 no (halts)

(forall ((x)) (implies (for-some ((x)) (p x))
                (for-some ((z)) (p x)))) ; not a theorem
;; 0.08 no
;; 0.11 no

(not (for-some ((x)) (forall ((y))        ; not a theorem
        (iff (a-member-of y x) (a-member-of y y)))))

; q=3 slow
(implies (and (forall ((x)) (not (less-than x x)))
              (forall ((x1) (x2) (x3))
                (implies (and (less-than x1 x2)
                              (less-than x2 x3))
                  (less-than x1 x3)))) ; not a theorem
  (forall ((x)) (for-some ((y)) (less-than x y))))
